{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Testing regular expressions for equivalence\"\n",
        "author: \"Martin Ong\"\n",
        "date: \"2024-1-12\"\n",
        "format: \n",
        "  html:\n",
        "    toc: true\n",
        "    embed-resources: true\n",
        "    code-fold: false\n",
        "    code-tools: true\n",
        "    code-line-numbers: true\n",
        "    number-sections: true\n",
        "---\n",
        "\n",
        "\n",
        "# Equivalence\n",
        "Any two languages (sets of strings) are equivalent if they each contain\n",
        "the same strings. Often, when working with regular languages, we deal with\n",
        "objects which recognise a particular language, however it is not immediately\n",
        "clear from looking at such an object what the language it recognises actually\n",
        "is.\n",
        "\n",
        "A common problem when dealing with such objects is determining whether two\n",
        "different objects are equivalent, in the sense that they recognise the same\n",
        "language.\n",
        "\n",
        "In this post, we will focus on finite automata. <!-- TODO: reword -->\n"
      ],
      "id": "28287410"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class Automaton(Protocol, Generic[T, S]):\n",
        "    \"\"\"\n",
        "    T: type of a state\n",
        "    S: type of a state's transition table\n",
        "    \"\"\"\n",
        "    start: T\n",
        "    states: set[T]\n",
        "    final: set[T]\n",
        "    transitions: dict[T, S]\n",
        "\n",
        "    def add_state(self, transitions: S) -> None:\n",
        "        ...\n",
        "\n",
        "    def make_final(self, state: T) -> None:\n",
        "        assert state in self.states\n",
        "        self.final.add(state)\n",
        "\n",
        "    def update(self, state: T, transitions: S) -> None:\n",
        "        self.transitions[state] = transitions\n",
        "\n",
        "    def evaluate(self, s: str) -> bool:\n",
        "        ..."
      ],
      "id": "f94fc946",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# Deterministic Finite Automata\n",
        "Deteriministic finite automata (DFAs) are one such object which behave nicely.\n",
        "It is well known that every DFA recognises a regular language, and every regular\n",
        "language is recognised by some DFA. Thus, we will begin by trying to compare\n",
        "two DFAs for equivalence.\n",
        "\n",
        "We can represent a DFA with the following python class"
      ],
      "id": "f8f0dfc5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class DFA(Automaton[int, dict[str, int]]):\n",
        "    next_state: int\n",
        "\n",
        "    def __init__(self) -> None:\n",
        "        self.transitions = {}\n",
        "        self.start = 0\n",
        "        self.states = { self.start }\n",
        "        self.final = set()\n",
        "        self.next_state = 1\n",
        "\n",
        "    def add_state(self, transitions: dict[str, int]) -> None:\n",
        "        self.states.add(self.next_state)\n",
        "        self.transitions[self.next_state] = transitions\n",
        "        self.next_state += 1\n",
        "\n",
        "    def evaluate(self, s: str) -> bool:\n",
        "        curr = self.start\n",
        "        for c in s:\n",
        "            curr = self.transitions[curr][c]\n",
        "        return curr in self.final"
      ],
      "id": "619b3835",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In this implementation, the `add_state` function creates a new state using the\n",
        "next unused integer as the new state ID.\n",
        "\n",
        "## Equivalence and Emptiness\n",
        "Consider two DFAs, $$D_1$$ and $$D_2$$. Now suppose that the languages recognised\n",
        "by the DFAs is given by $$L_1$$ and $$L_2$$ respectively.\n",
        "\n",
        "If the DFAs are equivalent, then every string in $$L_1$$ must be in $$L_2$$. That is,\n",
        "the automata agree on every string.\n",
        "\n",
        "However, if they are not equivalent, then there exists at least one string which\n",
        "is recognised by one DFA and not the other.\n",
        "\n",
        "Thinking about this in set notation (remember that languages are just sets), \n",
        "we have that if $$D_1$$ and $$D_2$$ are not equivalent, then there is a string\n",
        "$$x$$ such that $$x \\in L_1 \\cap \\lnot L_2$$ or $$x \\in L_1 \\cap \\lnot L_2$$.\n",
        "\n",
        "Hence, two DFAs are equivalent if the symmetric difference $$(L_1 \\cap \\lnot L_2) \\cup (\\lnot L_1 \\cap L_2)$$\n",
        "of the languages they recognise is empty; i.e. there is no string which is in the language\n",
        "of one DFA and not the other.\n",
        "\n",
        "## Boolean operations with automata\n",
        "\n",
        "### Union\n",
        "Given two DFA, we want to be able to construct a new DFA which recognises\n",
        "the language of strings which is recognised by either of the two input DFAs.\n",
        "The standard way to do this is via a \"product construction\".\n",
        "\n",
        "The idea behind a product construction is to create a new DFA which essentially\n",
        "runs both DFA at once on the same string, and then checks if either is in a final\n",
        "state at the end of the run.\n",
        "\n",
        "To do this, we need our new DFA to keep track of the state each DFA is in at each\n",
        "step. We can achieve this by storing the pair of the two states the two DFAs are in\n",
        "as the current state of our new DFA.\n",
        "\n",
        "If the states of the two DFAs are given by $$Q_1$$ and $$Q_2$$, then\n",
        "our new DFA should have states $$Q_1 \\times Q_2$$.\n",
        "\n",
        "Then, since we want to accept any string which is accepted by any of the two DFAs,\n",
        "any state pair which contains at least one final state in the original DFAs\n",
        "should be marked as final.\n",
        "\n",
        "[DIAGRAM HERE]\n",
        "\n",
        "In code, this would be"
      ],
      "id": "ab0da77a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class DFA(DFA):\n",
        "    def union(self, dfa: DFA) -> DFA:\n",
        "        res = DFA()\n",
        "\n",
        "        state_pairs = list(product(self.states, dfa.states))\n",
        "\n",
        "        res.start = state_pairs.index((self.start, dfa.start))\n",
        "        res.states = set(range(len(state_pairs)))\n",
        "        res.final = set(i for i in res.states if state_pairs[i][0] in self.final or state_pairs[i][1] in dfa.final)\n",
        "        res.next_state = len(state_pairs)\n",
        "        res.transitions = {state: dict() for state in res.states}\n",
        "\n",
        "        for state in res.states:\n",
        "            for a in ALPHABET:\n",
        "                res.transitions[state][a] = state_pairs.index((\n",
        "                    self.transitions[state_pairs[state][0]][a],\n",
        "                    dfa.transitions[state_pairs[state][1]][a]\n",
        "                ))\n",
        "\n",
        "        return res"
      ],
      "id": "01bca34b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Intersection\n",
        "To find a DFA recognising the intersection of the languages of two DFA, we only\n",
        "need to slightly modify the algorithm for the union construction.\n",
        "\n",
        "In particular, after running the DFA with state pairs,  <!-- TODO: reword -->\n",
        "we only need to change the choice of final states.\n",
        "\n",
        "For the intersection case, we only want to accept strings which are accepted\n",
        "by both DFAs, so the final states should be the states where each of the states\n",
        "in the pair are final states in the original DFAs.\n",
        "\n",
        "In python, this would be "
      ],
      "id": "ca68db69"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class DFA(DFA):\n",
        "    def union(self, dfa: DFA) -> DFA:\n",
        "        res = DFA()\n",
        "\n",
        "        state_pairs = list(product(self.states, dfa.states))\n",
        "\n",
        "        res.start = state_pairs.index((self.start, dfa.start))\n",
        "        res.states = set(range(len(state_pairs)))\n",
        "        # Notice the 'or' has become an 'and' on this line\n",
        "        res.final = set(i for i in res.states if state_pairs[i][0] in self.final and state_pairs[i][1] in dfa.final)\n",
        "        res.next_state = len(state_pairs)\n",
        "        res.transitions = {state: dict() for state in res.states}\n",
        "\n",
        "        for state in res.states:\n",
        "            for a in ALPHABET:\n",
        "                res.transitions[state][a] = state_pairs.index((\n",
        "                    self.transitions[state_pairs[state][0]][a],\n",
        "                    dfa.transitions[state_pairs[state][1]][a]\n",
        "                ))\n",
        "\n",
        "        return res"
      ],
      "id": "54226c1e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Complement\n",
        "Now we want to construct a DFA recognising the complement language of some\n",
        "given DFA. That is, a DFA which accepts every string that is rejected by the\n",
        "original DFA.\n",
        "\n",
        "Since we just want to switch the evaluation of the DFA on every input, it suffices\n",
        "to switch the final and non-final states.\n",
        "\n",
        "In python, this would look like"
      ],
      "id": "d3524932"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class DFA(DFA):\n",
        "    def complement(self) -> DFA:\n",
        "        dfa = deepcopy(self)\n",
        "        dfa.final = self.states - self.final\n",
        "        return dfa"
      ],
      "id": "fa05a959",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "my_custom_env",
      "language": "python",
      "display_name": "MATH3888 Env",
      "path": "/home/martin/.local/share/jupyter/kernels/my_custom_env"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}